# 这里记录的是笔者发现但不想在这个项目修复的bug。
# 会给出依照当前代码逻辑的解决方案。

1. Bug出现于<项目进度为视频第20集，下砸法术初步完成后>
一些带有无敌时间的技能在连续释放时，后释放的技能会在其结束时调用相应的代码结束无敌时间。
如果前个技能的无敌时间足够长，则会在这个时间段被后面的技能调用的player_hurt_box.disabled=false。
从而表现出角色虽然在闪烁（无敌），但是依旧会受到碰撞检测。
例如：下砸设置较长的无敌时间，下砸结束调用黑冲即可发现无敌失效。

这个问题最早在body碰撞后无敌立刻接黑冲出现过，视频作者和本人的解决办法均是：
	加入了一个逻辑判断 if invincible_timer.is_stopped(): 来确定是否有额外的timer尚未结束。

此时，考虑的情况是只有一个 hit & hurt box导致的timer，而黑冲为了图当时的便利使用动画设置无敌，没有创建timer。
在后面（引入下砸无敌）时，视频作者的结局方法是创建新的timer，逻辑判断用and连接。
但是这会导致一个问题：假设黑冲也设置了timer，或者假设有其他的动作需要新的无敌状态，
我们需要在每个相应的无敌状态下添加逻辑判断，然后and连接。
这非常麻烦，也不优雅，且逻辑不清晰。

笔者这里给出一个自觉更好的方案：
无敌状态函数里创建timer对象放入一个数组（或挂入一个TimerManager节点下，用group标记），
设置无敌结束前，先遍历所有的timer，只有都满足is_stopping才能设置hurt_box为false。

另一个更更好的方案，给player声明新的变量 timer_count: int = 0
每次调用无敌时间的函数就给这个count变量+1，timer结束时-1。
设置无敌结束前，只有都满足timer_count为0才能设置hurt_box为false。

考虑到这个复现项目做了太久，有点没有耐心，个人不打算修复这个bug了。
