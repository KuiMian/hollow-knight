# 这里记录的是笔者发现但不想在这个项目修复的bug。
# 会给出依照当前代码逻辑的解决方案。

1. Bug出现于<项目进度为视频第20集，下砸法术初步完成后>
一些带有无敌时间的技能在连续释放时，后释放的技能会在其结束时调用相应的代码结束无敌时间。
如果前个技能的无敌时间足够长，则会在这个时间段被后面的技能调用的player_hurt_box.disabled=false。
从而表现出角色虽然在闪烁（无敌），但是依旧会受到碰撞检测。
例如：下砸设置较长的无敌时间，下砸结束调用黑冲即可发现无敌失效。

这个问题最早在body碰撞后无敌立刻接黑冲出现过，视频作者和本人的解决办法均是：
	加入了一个逻辑判断 if invincible_timer.is_stopped(): 来确定是否有额外的timer尚未结束。

此时，考虑的情况是只有一个 hit & hurt box导致的timer，而黑冲为了图当时的便利使用动画设置无敌，没有创建timer。
在后面（引入下砸无敌）时，视频作者的结局方法是创建新的timer，逻辑判断用and连接。
但是这会导致一个问题：假设黑冲也设置了timer，或者假设有其他的动作需要新的无敌状态，
我们需要在每个相应的无敌状态下添加逻辑判断，然后and连接。
这非常麻烦，也不优雅，且逻辑不清晰。

笔者这里给出一个自觉更好的方案：
无敌状态函数里创建timer对象放入一个数组（或挂入一个TimerManager节点下，用group标记），
设置无敌结束前，先遍历所有的timer，只有都满足is_stopping才能设置hurt_box为false。

另一个更更好的方案，给player声明新的变量 timer_count: int = 0
每次调用无敌时间的函数就给这个count变量+1，timer结束时-1。
设置无敌结束前，只有都满足timer_count为0才能设置hurt_box为false。

考虑到这个复现项目做了太久，有点没有耐心，个人不打算修复这个bug了。

2. Bug出现于<项目进度为视频第17集，Boss Die State初步完成后>
这个bug早在完成Die State的时候提到了，即Boss血量为0时会执行完当前一系列行动再进入死亡状态
解决方式很简单，只需要给所有的状态添加force_transition相关的依赖就可以达成。

但是这么做很麻烦，有一个更好的方案是把force_transition相关的配置放入State父类即可。
不过现在暂时没有耐心做这个了。先复现完毕为主。

3. Bug出现于<项目进度为视频第2集，拼刀效果完成后>
存在一个bug，拼刀时如果boss能打到player，先进行碰撞检测的可能是player_hurt_box，从而进入hurt状态而非执行拼刀逻辑。

加状态锁是没法解决这个问题的。

个人认为想要解决只能让攻击部分推到重来。
首先将攻击动画的前几帧单独拿出来，然后做成拼刀动画，以及设计相应的拼刀状态。
然后每次攻击时先切入拼刀状态检测拼刀，没检测到在进入正式的攻击状态。
